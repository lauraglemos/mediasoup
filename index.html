<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CamGuro</title>
</head>
<body>
  <h1>CamGuro</h1>
  <video id="localVideo" autoplay muted playsinline></video>
  <video id="remoteVideo" autoplay playsinline></video>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io('http://localhost:3000');
    let localStream;
    let routerRtpCapabilities;

    // Solicitar permisos para cámara y micrófono
    async function requestPermissions() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter((device) => device.kind === 'videoinput');
        const audioDevices = devices.filter((device) => device.kind === 'audioinput');

        if (videoDevices.length === 0) {
          throw new Error('No se encontraron cámaras disponibles.');
        }

        if (audioDevices.length === 0) {
          throw new Error('No se encontraron micrófonos disponibles.');
        }

        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        console.log('Permisos de cámara y micrófono otorgados.');
        console.log('Stream local obtenido:', localStream);

        const localVideo = document.getElementById('localVideo');
        localVideo.srcObject = localStream;

      } catch (err) {
        console.error('Error al solicitar permisos:', err);
        alert('No se pudo acceder a la cámara y/o micrófono. Verifica los permisos.');
        throw err;
      }
    }

    // Iniciar transmisión y crear productores
    async function startStream() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        console.log('Stream local obtenido:', localStream);

        const localVideo = document.getElementById('localVideo');
        localVideo.srcObject = localStream;

        // Solicitar capacidades RTP del router
        socket.emit('getRouterRtpCapabilities', {}, (capabilities) => {
          routerRtpCapabilities = capabilities;
          console.log('Router RTP Capabilities:', routerRtpCapabilities);

          // Crear productores para cada pista
          localStream.getTracks().forEach((track) => {
            const kind = track.kind;

            // Buscar el codec correspondiente en las capacidades del router
            const codec = routerRtpCapabilities.codecs.find(c => c.kind === kind);

            if (!codec) {
              console.error(`No se encontró un codec compatible para ${kind}.`);
              return;
            }

            const rtpParameters = {
              codecs: [
                {
                  mimeType: codec.mimeType,
                  payloadType: codec.preferredPayloadType,
                  clockRate: codec.clockRate,
                  channels: codec.channels || 1,
                  parameters: codec.parameters || {},
                },
              ],
              headerExtensions: routerRtpCapabilities.headerExtensions.map(ext => ({
                uri: ext.uri,
                id: ext.preferredId,
              })),
              encodings: [{ ssrc: Math.floor(Math.random() * 1000000000) }],
            };

            console.log(`rtpParameters para ${kind}:`, rtpParameters);

            socket.emit('createProducer', { kind, rtpParameters }, (response) => {
              if (response.error) {
                console.error(`Error al crear productor ${kind}:`, response.error);
              } else {
                console.log(`Productor ${kind} creado con ID:`, response.id);

                // Crear consumidor para pruebas locales
                createConsumer(response.id);
              }
            });
          });
        });
      } catch (err) {
        console.error('Error al iniciar el stream:', err);
      }
    }



    // Crear consumidor
    function createConsumer(producerId) {
      if (!producerId) {
        console.error('Producer ID no está definido al llamar a createConsumer.');
        return;
      }

      socket.emit('createConsumer', { producerId }, async (response) => {
        if (response.error) {
          console.error('Error al crear consumidor:', response.error);
          return;
        }

        console.log(`Consumidor creado con ID: ${response.id}, tipo: ${response.kind}`);

        // Validar la pista recibida
        if (!response.rtpParameters) {
          console.error('No se han recibido parámetros RTP para el consumidor.');
          return;
        }

        // Crear RTCPeerConnection para recibir la pista
        const pc = new RTCPeerConnection();
        pc.addTransceiver(response.kind, { direction: 'recvonly' });

        // Configurar SDP remoto
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        // Configurar el consumidor en base a la respuesta del servidor
        pc.ontrack = (event) => {
          const track = event.track;
          console.log(`Pista ${response.kind} recibida:`, track);

          if (response.kind === 'audio') {
            const audioStream = new MediaStream();
            audioStream.addTrack(track);

            console.log('Pistas de audio en el stream remoto:', audioStream.getAudioTracks());

            const remoteAudio = new Audio();
            remoteAudio.srcObject = audioStream;
            remoteAudio.muted = false; // Asegúrate de que no esté silenciado
            remoteAudio.volume = 1.0; // Configura el volumen al máximo

            document.body.addEventListener('click', () => {
              remoteAudio.play().then(() => {
                console.log('Audio activado tras la interacción del usuario.');
              }).catch((err) => {
                console.error('Error al reproducir audio tras la interacción del usuario:', err);
              });
            });
          } else if (response.kind === 'video') {
            const remoteVideo = document.getElementById('remoteVideo');
            const videoStream = new MediaStream();
            videoStream.addTrack(track);
            remoteVideo.srcObject = videoStream;
          }
        };
      });
    }


    // Inicializar la aplicación
    document.addEventListener('DOMContentLoaded', async () => {
      try {
        await requestPermissions();
        await startStream();
      } catch (err) {
        console.error('Error en la inicialización:', err);
      }
    });
  </script>
</body>
</html>
